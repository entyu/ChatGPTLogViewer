<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ChatGPTãƒ­ã‚°ãƒ“ãƒ¥ãƒ¼ãƒ¯</title>
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      height: 100vh;
      background-color: #202123;
      color: white;
    }

    #left-column {
      width: 300px;
      background-color: #343541;
      overflow-y: auto;
      padding: 10px;
    }

    #right-column {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      background-color: #40414f;
    }

    .date-group {
      margin-bottom: 15px;
    }

    .date-header {
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 5px;
      color: #bbb;
      border-bottom: 1px solid #555;
    }

    .chat-item {
      padding: 6px 8px;
      cursor: pointer;
      border-radius: 4px;
      transition: background-color 0.3s;
    }

    .chat-item:hover {
      background-color: #565869;
    }

    .chat-message {
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 6px;
    }

    .user-message {
      background-color: #2d7df6;
      color: white;
      text-align: left;
    }

    .assistant-message {
      background-color: #565869;
      color: white;
      text-align: left;
    }

    /* åˆ†æãƒ†ãƒ¼ãƒ–ãƒ«ç”¨CSS */
    .analysis-table {
      width: 100%;
      border-collapse: collapse;
      color: #ddd;
      font-size: 14px;
      text-align: center;
      margin-bottom: 20px;
    }

    .analysis-table th, .analysis-table td {
      border: 1px solid #666;
      padding: 8px 10px;
    }

    .analysis-table th {
      background-color: #4a4b5e;
      font-weight: bold;
    }

    .analysis-table tr:nth-child(even) {
      background-color: #40414f;
    }

    .analysis-table tr:nth-child(odd) {
      background-color: #343541;
    }

    .analysis-table tr:hover {
      background-color: #565869;
    }

    .graph-container {
      display: flex;
      width: 100%;
      overflow-y: auto; /* ã‚³ãƒ³ãƒ†ãƒŠã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’è¨­å®š */
      height: 400px; /* é«˜ã•ã‚’ä»»æ„ã«èª¿æ•´ã—ã¦ãã ã•ã„ */
      color: white;
    }

    .graph-column {
      flex: 1; /* å¹…ã‚’åŠã€…ã« */
      overflow: hidden; /* å†…éƒ¨ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç„¡åŠ¹åŒ– */
      padding: 0 10px;
    }

    .graph-item {
      display: flex;
      align-items: center;
      height: 25px; /* è¡Œã®é«˜ã•ã‚’çµ±ä¸€ */
    }

  </style>
</head>

<body>
  <div id="left-column"></div>
  <div id="right-column">ä¼šè©±ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚</div>

  <script>
    async function loadJSON(file) {
      const response = await fetch(file);
      return await response.json();
    }

    function formatDate(timestamp) {
      const date = new Date(timestamp * 1000);
      return date.getFullYear() + "/" + (date.getMonth() + 1) + "/" + date.getDate();
    }

    function createChatList(conversations) {
      const container = document.getElementById('left-column');

      // åˆ†æã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
      const analysisDiv = document.createElement('div');
      analysisDiv.className = 'chat-item';
      analysisDiv.textContent = 'ğŸ“Š åˆ†æ';
      analysisDiv.onclick = showAnalysis;
      container.appendChild(analysisDiv);

      // æ—¥ä»˜ã”ã¨ã«ã¾ã¨ã‚ã‚‹
      const groups = {};
      conversations.forEach(convo => {
        const date = formatDate(convo.create_time);
        if (!groups[date]) groups[date] = [];
        groups[date].push(convo);
      });

      // æ—¥ä»˜ã‚’æ–°ã—ã„é †ã«ä¸¦ã¹ã‚‹
      const sortedDates = Object.keys(groups).sort((a, b) => new Date(b) - new Date(a));

      sortedDates.forEach(date => {
        const dateGroup = groups[date];
        let dailyTokensSum = 0, dailyTurnsSum = 0;

        const groupDiv = document.createElement('div');
        groupDiv.className = 'date-group';

        const dateHeader = document.createElement('div');
        dateHeader.className = 'date-header';
        dateHeader.textContent = date;
        groupDiv.appendChild(dateHeader);

        groups[date].forEach((convo, index) => {
          let currentNode = convo.current_node;
          let messages = [];
          while (currentNode) {
            const node = convo.mapping[currentNode];
            if (
              node.message &&
              node.message.content &&
              node.message.content.parts &&
              node.message.content.parts.length > 0
            ) {
              messages.push({
                role: node.message.author.role === "user" ? "USER" : "ChatGPT",
                text: node.message.content.parts.join("\n")
              });
            }
            currentNode = node.parent;
          }
          messages.reverse();

          // ãƒˆãƒ¼ã‚¯ãƒ³é›†è¨ˆï¼ˆSæœ€å¤§å€¤ï¼‰
          const analysis = [];
          let S = 0;
          messages.forEach((msg, idx) => {
            const tokens = msg.text.length;
            if (idx % 2 === 0) {
              analysis.push({X: tokens, Y: 0, T: tokens, S: (S += tokens)});
            } else {
              analysis[analysis.length - 1].Y = tokens;
              analysis[analysis.length - 1].T += tokens;
              analysis[analysis.length - 1].S = (S += tokens);
            }
          });

          const maxS = Math.max(...analysis.map(a => a.S));
          dailyTokensSum += maxS;
          dailyTurnsSum += analysis.length;

          // å·¦ã‚«ãƒ©ãƒ ã®å„ã‚¿ã‚¤ãƒˆãƒ«è¡¨ç¤º
          const itemDiv = document.createElement('div');
          itemDiv.className = 'chat-item';
          itemDiv.innerHTML = `${convo.title}<br>ã€${formatNumber(maxS)} tk/${analysis.length} Tã€‘`;
          itemDiv.onclick = () => displayConversation(convo);
          groupDiv.appendChild(itemDiv);
        });

        // æ—¥ä»˜ã”ã¨ã®åˆè¨ˆã‚’è¡¨ç¤º
        dateHeader.textContent = `${date}ã€${formatNumber(dailyTokensSum)} tk/${dailyTurnsSum} Tã€‘`;
        groupDiv.prepend(dateHeader);

        container.appendChild(groupDiv);
      });
    }

    function formatNumber(num) {
      if (num >= 1e9) return (num / 1e9).toFixed(2) + ' G';
      if (num >= 1e6) return (num / 1e6).toFixed(2) + ' M';
      if (num >= 1e3) return (num / 1e3).toFixed(1) + ' k';
      return num.toString();
    }

    function displayConversation(conversation) {
      const container = document.getElementById('right-column');
      container.innerHTML = '';

      let currentNode = conversation.current_node;
      let messages = [];

      while (currentNode != null) {
        const node = conversation.mapping[currentNode];
        if (
          node.message &&
          node.message.content &&
          node.message.content.parts &&
          node.message.content.parts.length > 0 &&
          (node.message.author.role !== "system" || node.message.metadata?.is_user_system_message)
        ) {
          let author = node.message.author.role;
          if (author === "assistant" || author === "tool") {
            author = "ChatGPT";
          } else if (author === "user") {
            author = "USER";
          }

          if (node.message.content.content_type === "text" || node.message.content.content_type === "multimodal_text") {
            const parts = node.message.content.parts.filter(part => typeof part === "string" && part.length > 0);
            if (parts.length > 0) {
              messages.push({ author, text: parts.join("\n") });
            }
          }
        }
        currentNode = node.parent;
      }

      messages.reverse(); // æ™‚ç³»åˆ—é †ã«ã™ã‚‹

      // --- ãƒˆãƒ¼ã‚¯ãƒ³åˆ†æå‡¦ç†ã®ä¿®æ­£ç‰ˆ ---
      let analysis = [];
      let cumulativeS = 0; // ãƒ­ã‚°åˆè¨ˆï¼ˆSï¼‰
      let cumulativeR = 0; // APIèª²é‡‘å†å¸°ç´¯ç©ï¼ˆRï¼‰
      let cumulativeSKV = 0; // ç´¯ç©KV (SKV)
      const maxKV = 128000; // 128kãƒªãƒŸãƒƒãƒˆè¨­å®š
      const max_context=128000;


      for (let i = 0; i < messages.length; i += 2) {
        const X = messages[i]?.text.length || 0;      // USERãƒˆãƒ¼ã‚¯ãƒ³
        const Y = messages[i + 1]?.text.length || 0;  // ChatGPTãƒˆãƒ¼ã‚¯ãƒ³
        const T = X + Y;                              // å…¥å‡ºåŠ›åˆè¨ˆ (T)
        
        // å‰ã‚¿ãƒ¼ãƒ³ã¾ã§ã®ãƒ­ã‚°åˆè¨ˆ(S)ã‚’128kã§åˆ¶é™ï¼ˆå®Ÿéš›ã®APIæŒ™å‹•ï¼‰
        const limitedPrevS = Math.min(cumulativeS, maxKV);

        // æ–°è¦KVè¨ˆç®— (KV)
//        const newKV = (limitedPrevS + X) * X;
        const newKV = (limitedPrevS + X + Y) * (X + Y);

        cumulativeS += T;                             // ãƒ­ã‚°åˆè¨ˆ (S)
        cumulativeSKV += newKV;

        // APIèª²é‡‘å†å¸°ç´¯ç©ãƒˆãƒ¼ã‚¯ãƒ³(R)
        cumulativeR += Math.min(cumulativeS, max_context);

        analysis.push({
          turn: (i / 2) + 1,
          X, Y, T,
          S: cumulativeS,
          KV: newKV,
          SKV: cumulativeSKV,
          R: cumulativeR
        });
      }

// åˆ†æãƒ†ãƒ¼ãƒ–ãƒ«HTMLã‚’ç”Ÿæˆ (CSSã‚¯ãƒ©ã‚¹åã¯é©å®œèª¿æ•´)
let tableHtml = `
<table style="width:100%;border-collapse:collapse;color:white;margin-bottom:15px;"">
  <tr>
    <th>ã‚¿ãƒ¼ãƒ³</th>
    <th>USER (X)</th>
    <th>ChatGPT (Y)</th>
    <th>å…¥å‡ºåŠ› (T)</th>
    <th>ãƒ­ã‚°åˆè¨ˆ (S)</th>
    <th>æ–°è¦KV (KV)</th>
    <th>ç´¯ç©KV (SKV)</th>
    <th>APIèª²é‡‘å†å¸°ç´¯ç© (R)</th>
  </tr>`;      
      analysis.forEach(row => {
        tableHtml += `<tr style="border-bottom:1px solid #666;text-align:center;">
          <td>${row.turn}</td>
          <td>${row.X}</td>
          <td>${row.Y}</td>
          <td>${row.T}</td>
          <td>${formatNumber(row.S)}</td>
          <td>${formatNumber(row.KV)}</td>
          <td>${formatNumber(row.SKV)}</td>
          <td>${formatNumber(row.R)}</td>
        </tr>`;
      });
      tableHtml += '</table>';

      container.innerHTML += tableHtml; // ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤º

      // --- ãƒˆãƒ¼ã‚¯ãƒ³åˆ†æå‡¦ç†ã“ã“ã¾ã§ ---

      messages.forEach(msg => {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message';

        if (msg.author === 'USER') {
          messageDiv.classList.add('user-message');
        } else {
          messageDiv.classList.add('assistant-message');
        }

        const formattedText = msg.text
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\n/g, "<br>")
          .replace(/&lt;br&gt;/g, "<br>");

        messageDiv.innerHTML = formattedText;
        container.appendChild(messageDiv);
      });
    }

    // åˆ†æç”»é¢è¡¨ç¤ºé–¢æ•°ï¼ˆä»®å®Ÿè£…ï¼‰
    function showAnalysis() {
      const container = document.getElementById('right-column');
      container.innerHTML = '<h2>åˆ†æãƒ‡ãƒ¼ã‚¿ï¼ˆæœˆæ¬¡ãƒ»æ—¥æ¬¡ï¼‰</h2>';

      // æœˆã”ã¨ã®ç´¯è¨ˆï¼ˆå®Ÿéš›ã®ãƒ­ã‚°ã‹ã‚‰é›†è¨ˆï¼‰
      const monthlyData = {};

      const maxKV = 128000; // KVè¨ˆç®—æ™‚ã®128kãƒˆãƒ¼ã‚¯ãƒ³ä¸Šé™è¨­å®š
      const max_context=128000;
      jsonData.forEach(convo => {
        const dateObj = new Date(convo.create_time * 1000);
        const month = `${dateObj.getFullYear()}/${dateObj.getMonth() + 1}`;
        if (!monthlyData[month]) monthlyData[month] = { T:0, S:0, R:0, SKV:0 };

        let currentNode = convo.current_node, messages = [];
        while (currentNode) {
          const node = convo.mapping[currentNode];
          if (node.message && node.message.content && node.message.content.parts && node.message.content.parts.length > 0) {
            messages.push(node.message.content.parts.join("\n"));
          }
          currentNode = node.parent;
        }
        messages.reverse();

        let cumulativeS = 0;  // ãƒ­ã‚°åˆè¨ˆ(S)
        let cumulativeR = 0;  // å†å¸°ç´¯ç©ãƒˆãƒ¼ã‚¯ãƒ³(R)
        let cumulativeSKV = 0; // ç´¯ç©KV(SKV)

        for (let i = 0; i < messages.length; i += 2) {
          const X = messages[i]?.length || 0;   // USERå…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³
          const Y = messages[i + 1]?.length || 0; // ChatGPTå‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³
          const T = X + Y;

          const limitedPrevS = Math.min(cumulativeS, maxKV); // 128kæ‰“ã¡åˆ‡ã‚Š

//          const newKV = (limitedPrevS + X) * X; // æ–°è¦KVè¨ˆç®—
          const newKV = (limitedPrevS + X + Y) * (X + Y);

          cumulativeS += T;                   // Sã‚’æ›´æ–°
          cumulativeR += Math.min(cumulativeS, max_context); // APIèª²é‡‘ç”¨ã®ç´¯ç©å†å¸°ãƒˆãƒ¼ã‚¯ãƒ³æ›´æ–°

          cumulativeSKV += newKV;             // SKVã‚’æ›´æ–°
        }

        monthlyData[month].T += messages.length / 2; // ã‚¿ãƒ¼ãƒ³æ•°
        monthlyData[month].S += cumulativeS;         // ç´¯ç©ãƒ­ã‚°åˆè¨ˆS
        monthlyData[month].R += cumulativeR;         // ç´¯ç©å†å¸°ãƒˆãƒ¼ã‚¯ãƒ³R
        monthlyData[month].SKV += cumulativeSKV;     // ç´¯ç©KVè¨ˆç®—SKV
      });


      // æœˆæ¬¡ãƒ‡ãƒ¼ã‚¿è¡¨ç¤ºãƒ†ãƒ¼ãƒ–ãƒ«
let tableHtml = `
<table class="analysis-table">
  <tr>
    <th>æœˆ</th>
    <th>ã‚¿ãƒ¼ãƒ³æ•° (T)</th>
    <th>ãƒ­ã‚°åˆè¨ˆ (S)</th>
    <th>ç´¯ç©SKV (KV)</th>
    <th>APIèª²é‡‘å†å¸°ç´¯ç©  (R)</th>
  </tr>`;

      // æœˆã‚’é™é †ï¼ˆæ–°ã—ã„æœˆãŒä¸Šï¼‰ã§ä¸¦ã¹æ›¿ãˆ
      Object.entries(monthlyData)
        .sort((a, b) => new Date(b[0] + '/01') - new Date(a[0] + '/01'))
        .forEach(([month, data]) => {
          tableHtml += `
          <tr>
            <td>${month}</td>
            <td>${formatNumber(data.T)}</td>
            <td>${formatNumber(data.S)}</td>
            <td>${formatNumber(data.SKV)}</td>
            <td>${formatNumber(data.R)}</td>
          </tr>`;
      });

      tableHtml += '</table>';
      container.innerHTML += tableHtml;


      // æ—¥æ¬¡ã‚°ãƒ©ãƒ•ã®ã‚¿ã‚¤ãƒˆãƒ«ã¨ã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œæˆ
      container.innerHTML += '<h3>æ—¥æ¬¡ã‚°ãƒ©ãƒ•APIå†å¸°(R)</h3>';


      const dailyData = {};
      jsonData.forEach(convo => {
        const date = formatDate(convo.create_time);
        if (!dailyData[date]) dailyData[date] = {T:0, S:0, R:0};

        let currentNode = convo.current_node, messages = [];
        while (currentNode) {
          const node = convo.mapping[currentNode];
          if (
            node.message &&
            node.message.content &&
            node.message.content.parts &&
            node.message.content.parts.length > 0 // â† æ˜ç¢ºã«è¿½åŠ ã—ãŸæ¡ä»¶
          ) {
            messages.push(node.message.content.parts.join("\n"));
          }
          currentNode = node.parent;
        }
        let S=0, R=0;
        messages.forEach((text, idx)=>{
          S += text.length;
          R += S;
        });

        dailyData[date].T += messages.length / 2;
        dailyData[date].S += S;
        dailyData[date].R += R;
      });

      // ã‚°ãƒ©ãƒ•ã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œæˆï¼ˆå‹•çš„ã«JSã§ã®ã¿ä½œæˆï¼‰
      const graphContainer = document.createElement('div');
      graphContainer.style.display = 'flex';
      graphContainer.style.flexDirection = 'column';
      graphContainer.style.width = '100%';
      graphContainer.style.height = '400px'; // ã“ã“ã‚’çµ±ä¸€ï¼ˆ400pxæ¨å¥¨ï¼‰
      graphContainer.style.overflowY = 'auto';
      graphContainer.style.color = 'white';
      graphContainer.style.border = '1px solid #666';

      // ã‚°ãƒ©ãƒ•ã®æœ€å¤§å€¤ï¼ˆRï¼‰ã®å–å¾—
      const maxValueR = Math.max(...Object.values(dailyData).map(data => data.R));

      // ã‚°ãƒ©ãƒ•æç”»ç”¨divã‚’ä½œæˆ
      Object.entries(dailyData)
      .sort((a, b) => new Date(b[0]) - new Date(a[0]))
      .forEach(([date, data]) => {
        const valueR = data.R;
        const barPercent = (valueR / maxValueR) * 100; // æœ€å¤§å€¤ã‚’100%ã¨ã—ã¦ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°

        const graphItem = document.createElement('div');
        graphItem.style.display = 'flex';
        graphItem.style.alignItems = 'center';
        graphItem.style.height = '25px';
        graphItem.style.marginBottom = '2px';

        // ãƒãƒ¼è¡¨ç¤ºé ˜åŸŸï¼ˆå³æƒãˆï¼‰
        const barContainer = document.createElement('div');
        barContainer.style.flex = '1';
        barContainer.style.display = 'flex';
        barContainer.style.justifyContent = 'flex-end';

        const barDiv = document.createElement('div');
        barDiv.style.width = `${barPercent}%`;
        barDiv.style.maxWidth = '100%';
        barDiv.style.background = 'linear-gradient(to right, #f9cce3, #f48fb1)';
        barDiv.style.border = '1px solid #ffd6e8';
        barDiv.style.height = '15px';

        // æ—¥ä»˜ãªã©è¡¨ç¤ºé ˜åŸŸï¼ˆå·¦æƒãˆãƒ»å›ºå®šå¹…ï¼‰
        const dateDiv = document.createElement('div');
        dateDiv.style.flex = '0 0 300px';
        dateDiv.style.textAlign = 'left';
        dateDiv.textContent = `${date} (${data.T}T) ${formatNumber(valueR)} tk(R)`;


        barContainer.appendChild(barDiv);
        graphItem.appendChild(barContainer);
        graphItem.appendChild(dateDiv);
        graphContainer.appendChild(graphItem);
      });

      // ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒŠã«ã‚°ãƒ©ãƒ•ã‚³ãƒ³ãƒ†ãƒŠã‚’è¿½åŠ ï¼ˆã“ã“ã§ä¸€å›ã ã‘è¿½åŠ ï¼‰
      container.appendChild(graphContainer);

    }

    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã§jsonDataã‚’å®šç¾©
    let jsonData = [];
    
    // ãƒ­ã‚°ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
    async function loadJSON(file) {
      try {
        const response = await fetch(file);
        if (!response.ok) {
          console.error("ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", response.status, response.statusText);
          return;
        }
        jsonData = await response.json();
        console.log("èª­ã¿è¾¼ã¿æˆåŠŸï¼", jsonData); // èª­ã¿è¾¼ã‚“ã JSONã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«è¡¨ç¤º
        return jsonData;
      } catch (e) {
        console.error("JSONèª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ:", e);
      }
    }

    // ã“ã“ã§å®Ÿéš›ã«JSONã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ã€createChatListã«æ¸¡ã—ã¾ã™ã€‚
    loadJSON('conversations.json').then(data => {
      if (data) {
        createChatList(data);
      } else {
        console.error("ãƒ‡ãƒ¼ã‚¿ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚");
      }
    });
    </script>
  </body>
</html>
